// @generated by protobuf-ts 2.9.0 with parameter optimize_code_size
// @generated from protobuf file "auth-only-service.proto" (syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { AuthOnlyService } from "./auth-only-service";
import type { BookingAvailability } from "./common-messages";
import type { BedList } from "./common-messages";
import type { ModifyBedRequest } from "./auth-only-service";
import type { BedMutableInfo } from "./common-messages";
import type { GetMyReviewResponse } from "./auth-only-service";
import type { BedId } from "./common-messages";
import type { ReviewRequest } from "./auth-only-service";
import type { BookResponse } from "./auth-only-service";
import type { Booking } from "./common-messages";
import type { ProfilePic } from "./common-messages";
import type { VerifyMailResponse } from "./auth-only-service";
import type { VerifyMailRequest } from "./auth-only-service";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { Empty } from "./common-messages";
import type { AccountInfo } from "./common-messages";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Every account is identified only by the publicKey of the client. For this service the authtoken has to be always passed in metadata with the key "authtoken"
 *
 * @generated from protobuf service AuthOnlyService
 */
export interface IAuthOnlyServiceClient {
    /**
     * Called only if the account does not exist (verified or not)
     *
     * @generated from protobuf rpc: SignUp(AccountInfo) returns (Empty);
     */
    signUp(input: AccountInfo, options?: RpcOptions): UnaryCall<AccountInfo, Empty>;
    /**
     * @generated from protobuf rpc: logout(Empty) returns (Empty);
     */
    logout(input: Empty, options?: RpcOptions): UnaryCall<Empty, Empty>;
    // FOR EVERY FOLLOWING RPC (TILL SERVICE LAST RPC) IS ASSUMED THAT THE CALLER ACCOUNT EXIST

    /**
     * Returns ok=false also if the account is already verified
     *
     * @generated from protobuf rpc: VerifyMail(VerifyMailRequest) returns (VerifyMailResponse);
     */
    verifyMail(input: VerifyMailRequest, options?: RpcOptions): UnaryCall<VerifyMailRequest, VerifyMailResponse>;
    /**
     * @generated from protobuf rpc: GetAccountInfo(Empty) returns (AccountInfo);
     */
    getAccountInfo(input: Empty, options?: RpcOptions): UnaryCall<Empty, AccountInfo>;
    /**
     * @generated from protobuf rpc: GetProfilePic(Empty) returns (ProfilePic);
     */
    getProfilePic(input: Empty, options?: RpcOptions): UnaryCall<Empty, ProfilePic>;
    /**
     * @generated from protobuf rpc: SetProfilePic(ProfilePic) returns (Empty);
     */
    setProfilePic(input: ProfilePic, options?: RpcOptions): UnaryCall<ProfilePic, Empty>;
    /**
     * It also delete all his beds and booking availabilities, review to other's beds (adjusting averageEvaluation)
     *
     * @generated from protobuf rpc: DeleteAccount(Empty) returns (Empty);
     */
    deleteAccount(input: Empty, options?: RpcOptions): UnaryCall<Empty, Empty>;
    /**
     * If the mail is changed, is needed to verify the account (and the eventual old verification code becomed invalid), you can call this function even if
     * the account is not verified, because for example the mail was wrong.
     *
     * @generated from protobuf rpc: UpdateAccountInfo(AccountInfo) returns (Empty);
     */
    updateAccountInfo(input: AccountInfo, options?: RpcOptions): UnaryCall<AccountInfo, Empty>;
    // FOR EVERY FOLLOWING RPC (TILL SERVICE LAST RPC) IS ASSUMED THAT THE CALLER HAS A VERIFIED ACCOUNT

    /**
     * GUEST RPCs
     * If guest can pay, he must do it within 1 minute
     * "Human proof token" are then sent through mail to both guest, and host
     * If the guest account will be deleted in the following minute or the booking becomes invalid, the will be no booking
     *
     * @generated from protobuf rpc: Book(Booking) returns (BookResponse);
     */
    book(input: Booking, options?: RpcOptions): UnaryCall<Booking, BookResponse>;
    /**
     * Is assumed that A user can review only a booked bed that has no review from that user
     *
     * @generated from protobuf rpc: Review(ReviewRequest) returns (Empty);
     */
    review(input: ReviewRequest, options?: RpcOptions): UnaryCall<ReviewRequest, Empty>;
    /**
     * It returns the optional own review for the BedId
     *
     * @generated from protobuf rpc: GetMyReview(BedId) returns (GetMyReviewResponse);
     */
    getMyReview(input: BedId, options?: RpcOptions): UnaryCall<BedId, GetMyReviewResponse>;
    /**
     * rpc GetMyBookings(Empty) returns (BookingInfoList); // NOT GOING TO BE IMPLEMENTED
     *
     * The client has a review on that BedId
     *
     * @generated from protobuf rpc: RemoveReview(BedId) returns (Empty);
     */
    removeReview(input: BedId, options?: RpcOptions): UnaryCall<BedId, Empty>;
    /**
     * HOST RPCs
     *
     * @generated from protobuf rpc: AddBed(BedMutableInfo) returns (Empty);
     */
    addBed(input: BedMutableInfo, options?: RpcOptions): UnaryCall<BedMutableInfo, Empty>;
    /**
     * @generated from protobuf rpc: ModifyMyBed(ModifyBedRequest) returns (Empty);
     */
    modifyMyBed(input: ModifyBedRequest, options?: RpcOptions): UnaryCall<ModifyBedRequest, Empty>;
    /**
     * @generated from protobuf rpc: RemoveMyBed(BedId) returns (Empty);
     */
    removeMyBed(input: BedId, options?: RpcOptions): UnaryCall<BedId, Empty>;
    /**
     * @generated from protobuf rpc: GetMyBeds(Empty) returns (BedList);
     */
    getMyBeds(input: Empty, options?: RpcOptions): UnaryCall<Empty, BedList>;
    /**
     * Is assumed that the booking isn't available and the caller own the bed with the specified bedId
     *
     * @generated from protobuf rpc: AddBookingAvailability(BookingAvailability) returns (Empty);
     */
    addBookingAvailability(input: BookingAvailability, options?: RpcOptions): UnaryCall<BookingAvailability, Empty>;
    /**
     * rpc ModifyBookingAvailability(BookingAvailability) returns (Empty); // NOT GOING TO BE IMPLEMENTED!!
     *
     * Is assumed that the booking is available and the caller own the bed with the specified bedId
     *
     * @generated from protobuf rpc: RemoveBookAvailability(BookingAvailability) returns (Empty);
     */
    removeBookAvailability(input: BookingAvailability, options?: RpcOptions): UnaryCall<BookingAvailability, Empty>;
}
/**
 * Every account is identified only by the publicKey of the client. For this service the authtoken has to be always passed in metadata with the key "authtoken"
 *
 * @generated from protobuf service AuthOnlyService
 */
export class AuthOnlyServiceClient implements IAuthOnlyServiceClient, ServiceInfo {
    typeName = AuthOnlyService.typeName;
    methods = AuthOnlyService.methods;
    options = AuthOnlyService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Called only if the account does not exist (verified or not)
     *
     * @generated from protobuf rpc: SignUp(AccountInfo) returns (Empty);
     */
    signUp(input: AccountInfo, options?: RpcOptions): UnaryCall<AccountInfo, Empty> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<AccountInfo, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: logout(Empty) returns (Empty);
     */
    logout(input: Empty, options?: RpcOptions): UnaryCall<Empty, Empty> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, Empty>("unary", this._transport, method, opt, input);
    }
    // FOR EVERY FOLLOWING RPC (TILL SERVICE LAST RPC) IS ASSUMED THAT THE CALLER ACCOUNT EXIST

    /**
     * Returns ok=false also if the account is already verified
     *
     * @generated from protobuf rpc: VerifyMail(VerifyMailRequest) returns (VerifyMailResponse);
     */
    verifyMail(input: VerifyMailRequest, options?: RpcOptions): UnaryCall<VerifyMailRequest, VerifyMailResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<VerifyMailRequest, VerifyMailResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: GetAccountInfo(Empty) returns (AccountInfo);
     */
    getAccountInfo(input: Empty, options?: RpcOptions): UnaryCall<Empty, AccountInfo> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, AccountInfo>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: GetProfilePic(Empty) returns (ProfilePic);
     */
    getProfilePic(input: Empty, options?: RpcOptions): UnaryCall<Empty, ProfilePic> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, ProfilePic>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: SetProfilePic(ProfilePic) returns (Empty);
     */
    setProfilePic(input: ProfilePic, options?: RpcOptions): UnaryCall<ProfilePic, Empty> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<ProfilePic, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * It also delete all his beds and booking availabilities, review to other's beds (adjusting averageEvaluation)
     *
     * @generated from protobuf rpc: DeleteAccount(Empty) returns (Empty);
     */
    deleteAccount(input: Empty, options?: RpcOptions): UnaryCall<Empty, Empty> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * If the mail is changed, is needed to verify the account (and the eventual old verification code becomed invalid), you can call this function even if
     * the account is not verified, because for example the mail was wrong.
     *
     * @generated from protobuf rpc: UpdateAccountInfo(AccountInfo) returns (Empty);
     */
    updateAccountInfo(input: AccountInfo, options?: RpcOptions): UnaryCall<AccountInfo, Empty> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<AccountInfo, Empty>("unary", this._transport, method, opt, input);
    }
    // FOR EVERY FOLLOWING RPC (TILL SERVICE LAST RPC) IS ASSUMED THAT THE CALLER HAS A VERIFIED ACCOUNT

    /**
     * GUEST RPCs
     * If guest can pay, he must do it within 1 minute
     * "Human proof token" are then sent through mail to both guest, and host
     * If the guest account will be deleted in the following minute or the booking becomes invalid, the will be no booking
     *
     * @generated from protobuf rpc: Book(Booking) returns (BookResponse);
     */
    book(input: Booking, options?: RpcOptions): UnaryCall<Booking, BookResponse> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<Booking, BookResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Is assumed that A user can review only a booked bed that has no review from that user
     *
     * @generated from protobuf rpc: Review(ReviewRequest) returns (Empty);
     */
    review(input: ReviewRequest, options?: RpcOptions): UnaryCall<ReviewRequest, Empty> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReviewRequest, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * It returns the optional own review for the BedId
     *
     * @generated from protobuf rpc: GetMyReview(BedId) returns (GetMyReviewResponse);
     */
    getMyReview(input: BedId, options?: RpcOptions): UnaryCall<BedId, GetMyReviewResponse> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept<BedId, GetMyReviewResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * rpc GetMyBookings(Empty) returns (BookingInfoList); // NOT GOING TO BE IMPLEMENTED
     *
     * The client has a review on that BedId
     *
     * @generated from protobuf rpc: RemoveReview(BedId) returns (Empty);
     */
    removeReview(input: BedId, options?: RpcOptions): UnaryCall<BedId, Empty> {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept<BedId, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * HOST RPCs
     *
     * @generated from protobuf rpc: AddBed(BedMutableInfo) returns (Empty);
     */
    addBed(input: BedMutableInfo, options?: RpcOptions): UnaryCall<BedMutableInfo, Empty> {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept<BedMutableInfo, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: ModifyMyBed(ModifyBedRequest) returns (Empty);
     */
    modifyMyBed(input: ModifyBedRequest, options?: RpcOptions): UnaryCall<ModifyBedRequest, Empty> {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return stackIntercept<ModifyBedRequest, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: RemoveMyBed(BedId) returns (Empty);
     */
    removeMyBed(input: BedId, options?: RpcOptions): UnaryCall<BedId, Empty> {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        return stackIntercept<BedId, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: GetMyBeds(Empty) returns (BedList);
     */
    getMyBeds(input: Empty, options?: RpcOptions): UnaryCall<Empty, BedList> {
        const method = this.methods[15], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, BedList>("unary", this._transport, method, opt, input);
    }
    /**
     * Is assumed that the booking isn't available and the caller own the bed with the specified bedId
     *
     * @generated from protobuf rpc: AddBookingAvailability(BookingAvailability) returns (Empty);
     */
    addBookingAvailability(input: BookingAvailability, options?: RpcOptions): UnaryCall<BookingAvailability, Empty> {
        const method = this.methods[16], opt = this._transport.mergeOptions(options);
        return stackIntercept<BookingAvailability, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * rpc ModifyBookingAvailability(BookingAvailability) returns (Empty); // NOT GOING TO BE IMPLEMENTED!!
     *
     * Is assumed that the booking is available and the caller own the bed with the specified bedId
     *
     * @generated from protobuf rpc: RemoveBookAvailability(BookingAvailability) returns (Empty);
     */
    removeBookAvailability(input: BookingAvailability, options?: RpcOptions): UnaryCall<BookingAvailability, Empty> {
        const method = this.methods[17], opt = this._transport.mergeOptions(options);
        return stackIntercept<BookingAvailability, Empty>("unary", this._transport, method, opt, input);
    }
}
